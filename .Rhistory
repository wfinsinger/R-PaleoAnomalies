# The code finally allows plotting the resampled data, the smoothed data, the thresholds, as well as the detected
# anomalies (values beyond the noise threshold).
##########################################################################################################
rm(list = ls())
### 1) Read r functions ########################################################
source("./R/pretreatment_full.r")
source("./R/pretreatment_data.r")
source("./R/SeriesDetrend.r")
source("./R/SeriesThreshold_v5.r")
source("./R/SNI.r")
source("./R/PlotAnomalies.r")
### Load data ##########################################################
### Charcoal data ###
co <- read.csv("./Data-In/CO_charData.csv", header = T)
co <- dplyr::rename(co, "AgeTop" = "ageTop..yr.BP.")
co <- dplyr::rename(co, "AgeBot" = "AgeBot..yr.BP.")
co <- dplyr::rename(co, "char" = "CharCount.....")
## Pretreatment
min.ages <- min(co$AgeTop)
max.ages <- max(co$AgeTop)
yr.interp <- 15
co.i1 <- pretreatment_data(series = co, out = "accI", series.name = "co",
first = -51, last = 7500, yrInterp = yr.interp)
plot(co.i1$raw$series$age, co.i1$raw$series$char, type = "l")
lines(co.i1$int$series.int$age, co.i1$int$series.int$char, col = "red")
## Detrending
co.detr1 <- SeriesDetrend(series = co.i1, smoothing.yr = 500,
detr.type = "rob.loess", out.dir = "Figures")
co.detr1 <- SeriesDetrend(series = co.i1, smoothing.yr = 500,
detr.type = "mov.mode", out.dir = "Figures")
## GMM (2 components)
char.thresh.gl1 <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500, span.sm = 0.2,
gm.local = F, keep_consecutive = F,
out.dir = "Figures")
char.thresh.loc <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500,
gm.local = T, keep_consecutive = F,
out.dir = "Figures")
series = char.thresh.loc
series = char.thresh.gl1
proxy = "charAR"
x.lim = NULL
plot.x = T
plot.neg = F
d <- series
i <- proxy
if (is.null(x.lim)) {
x.lim <- rev(c(min(d$int$series.int$age), max(d$int$series.int$age)))
}
y.lim <- c(min(d$int$series.int[[proxy]], na.rm = T),
max(d$int$series.int[[proxy]], na.rm = T))
## Gather data
d <- series
i <- proxy
peaks_neg_ages <- d$thresh$peaks.neg.ages
peaks_pos_ages <- d$thresh$peaks.pos.ages
RI_neg <- d$thresh$RI_neg
RI_pos <- d$thresh$RI_pos
if (is.null(x.lim)) {
x.lim <- rev(c(min(d$int$series.int$age), max(d$int$series.int$age)))
}
y.lim <- c(min(c(peaks_neg_ages, peaks_pos_ages), na.rm = T),
max(c(peaks_neg_ages, peaks_pos_ages), na.rm = T))
y.lim <- c(min(c(RI_neg, RI_pos), na.rm = T),
max(c(RI_neg, RI_pos), na.rm = T))
y.lim <- c(0, max(c(RI_neg, RI_pos), na.rm = T))
# Plot data
#par(mfrow = c(1,1), mar = c(5,4,2,0.5))
plot(peaks_neg_ages, RI_neg, type = "l", axes = F,
ylab = paste(proxy, "return interval \n (years)"),
xlab = "", xlim = x.lim, ylim = y.lim)
# Plot data
#par(mfrow = c(1,1), mar = c(5,4,2,0.5))
plot(peaks_pos_ages, RI_pos, type = "l", axes = F,
ylab = paste(proxy, "return interval \n (years)"),
xlab = "", xlim = x.lim, ylim = y.lim)
# Plot data
#par(mfrow = c(1,1), mar = c(5,4,2,0.5))
plot(peaks_pos_ages, RI_pos, type = "l", axes = F,
ylab = paste(proxy, "return interval \n (years)"),
xlab = "", xlim = x.lim, ylim = y.lim)
# Plot data
#par(mfrow = c(1,1), mar = c(5,4,2,0.5))
plot(peaks_pos_ages, RI_pos, type = "l", axes = F,
ylab = paste(proxy, "return interval \n (years)"), lwd = 2,
xlab = "", xlim = x.lim, ylim = y.lim)
if (plot.neg == T) {
lines(peaks_neg_ages, RI_neg, col = "blue", lwd = 2)
}
axis(1, labels = plot.x)
axis(2)
View(Plot.Anomalies)
source("./R/Plot_ReturnIntervals.r")
Plot_ReturnIntervals(series = char.thresh.gl1, proxy = "charAR")
## Plotit
layout(1)
par(mfrow = c(2,1), mar = c(1,5,2,0.5))
Plot.Anomalies(series = char.thresh.gl1, proxy = "charAR", plot.crosses = T,
plot.x = F, plot.neg = T)
Plot_ReturnIntervals(series = char.thresh.gl1, proxy = "charAR")
Plot.Anomalies(series = char.thresh.loc, proxy = "charAR", plot.crosses = T,
plot.x = T, plot.neg = T)
Plot_ReturnIntervals(series = char.thresh.loc, proxy = "charAR")
View(SeriesThresh)
View(SNI)
source('~/Documents/GitHub/R-PaleoAnomalies_notGit_v2/R/SeriesThreshold_v5.R')
char.thresh.loc <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500,
gm.local = T, keep_consecutive = F,
out.dir = "Figures")
## Plotit
layout(1)
par(mfrow = c(2,1), mar = c(1,5,2,0.5))
Plot.Anomalies(series = char.thresh.gl1, proxy = "charAR", plot.crosses = T,
plot.x = F, plot.neg = T)
Plot_ReturnIntervals(series = char.thresh.gl1, proxy = "charAR")
Plot.Anomalies(series = char.thresh.loc, proxy = "charAR", plot.crosses = T,
plot.x = T, plot.neg = T)
Plot_ReturnIntervals(series = char.thresh.loc, proxy = "charAR")
source('~/Documents/GitHub/R-PaleoAnomalies_notGit_v2/R/SeriesThreshold_v5.R')
char.thresh.loc <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500,
gm.local = T, keep_consecutive = F,
out.dir = "Figures")
Plot.Anomalies(series = char.thresh.loc, proxy = "charAR", plot.crosses = T,
plot.x = T, plot.neg = T)
Plot_ReturnIntervals(series = char.thresh.loc, proxy = "charAR")
source('~/Documents/GitHub/R-PaleoAnomalies_notGit_v2/R/SeriesThreshold_v5.R')
char.thresh.loc <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500,
gm.local = T, keep_consecutive = F,
out.dir = "Figures")
Plot.Anomalies(series = char.thresh.loc, proxy = "charAR", plot.crosses = T,
plot.x = T, plot.neg = T)
Plot_ReturnIntervals(series = char.thresh.loc, proxy = "charAR")
View(SeriesThresh)
source('~/Documents/GitHub/R-PaleoAnomalies_notGit_v2/R/SeriesThreshold_v5.R')
char.thresh.loc <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500,
gm.local = T, keep_consecutive = F,
out.dir = "Figures")
Plot.Anomalies(series = char.thresh.loc, proxy = "charAR", plot.crosses = T,
plot.x = T, plot.neg = T)
Plot_ReturnIntervals(series = char.thresh.loc, proxy = "charAR")
View(SeriesThresh)
##########################################################################################################
# R code to detect positive and negative anomalies in palaeoecological time series.
# Walter Finsinger, 03 June 2020
# The functions are loaded at the beginning. Explanations concerning the
#   user-determined parameters are given in the functions files.
# The code does the following:
# Firstly, the time series are virtually resampled to equal sampling intervals. To do this,
# we used the pretreatment() function (aka pretreatment as from CharAnalysis, Higuera et al., 200x),
# which we slightly modified in order to get all output data needed later.
# Then, the resampled time series are detrended,
# and Figures are produced to visually evaluate the smoothed record and the detrended data.
# Thereafter, we fitted a 2-component Gaussian Mixture Model (GMM) to the detrended data.
# One of the components is centred around 0, and we set the nth quantile of the gaussian distribution of that component to determine
# the threshold separating the noise from the signal. Figures are produced to visually evaluate the GMMs.
# The code finally allows plotting the resampled data, the smoothed data, the thresholds, as well as the detected
# anomalies (values beyond the noise threshold).
##########################################################################################################
rm(list = ls())
### 1) Read r functions ########################################################
source("./R/pretreatment_full.r")
source("./R/pretreatment_data.r")
source("./R/SeriesDetrend.r")
source("./R/SeriesThreshold_v5.r")
source("./R/SNI.r")
source("./R/PlotAnomalies.r")
source("./R/Plot_ReturnIntervals.r")
### Load data ##########################################################
### Charcoal data ###
co <- read.csv("./Data-In/CO_charData.csv", header = T)
co <- dplyr::rename(co, "AgeTop" = "ageTop..yr.BP.")
co <- dplyr::rename(co, "AgeBot" = "AgeBot..yr.BP.")
co <- dplyr::rename(co, "char" = "CharCount.....")
## Pretreatment
min.ages <- min(co$AgeTop)
max.ages <- max(co$AgeTop)
yr.interp <- 15
co.i1 <- pretreatment_data(series = co, out = "accI", series.name = "co",
first = -51, last = 7500, yrInterp = yr.interp)
plot(co.i1$raw$series$age, co.i1$raw$series$char, type = "l")
lines(co.i1$int$series.int$age, co.i1$int$series.int$char, col = "red")
## Detrending
co.detr1 <- SeriesDetrend(series = co.i1, smoothing.yr = 500,
detr.type = "rob.loess", out.dir = "Figures")
co.detr1 <- SeriesDetrend(series = co.i1, smoothing.yr = 500,
detr.type = "mov.mode", out.dir = "Figures")
## GMM (2 components)
char.thresh.gl1 <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500, span.sm = 0.2,
gm.local = F, keep_consecutive = F,
out.dir = "Figures")
char.thresh.loc <- SeriesThresh(series = co.detr1, proxy = "charAR", thresh.yr = 500,
thresh.value = 0.99, smoothing.yr = 500,
gm.local = T, keep_consecutive = F,
out.dir = "Figures")
rm(char.thresh.gl1, co, co.detr1, co.i1)
View(SeriesThresh)
series = co.detr1
proxy = "charAR"
t.lim = NULL
thresh.yr = 500
thresh.value = 0.99
##########################################################################################################
# R code to detect positive and negative anomalies in palaeoecological time series.
# Walter Finsinger, 03 June 2020
# The functions are loaded at the beginning. Explanations concerning the
#   user-determined parameters are given in the functions files.
# The code does the following:
# Firstly, the time series are virtually resampled to equal sampling intervals. To do this,
# we used the pretreatment() function (aka pretreatment as from CharAnalysis, Higuera et al., 200x),
# which we slightly modified in order to get all output data needed later.
# Then, the resampled time series are detrended,
# and Figures are produced to visually evaluate the smoothed record and the detrended data.
# Thereafter, we fitted a 2-component Gaussian Mixture Model (GMM) to the detrended data.
# One of the components is centred around 0, and we set the nth quantile of the gaussian distribution of that component to determine
# the threshold separating the noise from the signal. Figures are produced to visually evaluate the GMMs.
# The code finally allows plotting the resampled data, the smoothed data, the thresholds, as well as the detected
# anomalies (values beyond the noise threshold).
##########################################################################################################
rm(list = ls())
### 1) Read r functions ########################################################
source("./R/pretreatment_full.r")
source("./R/pretreatment_data.r")
source("./R/SeriesDetrend.r")
source("./R/SeriesThreshold_v5.r")
source("./R/SNI.r")
source("./R/PlotAnomalies.r")
source("./R/Plot_ReturnIntervals.r")
### Load data ##########################################################
### Charcoal data ###
co <- read.csv("./Data-In/CO_charData.csv", header = T)
co <- dplyr::rename(co, "AgeTop" = "ageTop..yr.BP.")
co <- dplyr::rename(co, "AgeBot" = "AgeBot..yr.BP.")
co <- dplyr::rename(co, "char" = "CharCount.....")
## Pretreatment
min.ages <- min(co$AgeTop)
max.ages <- max(co$AgeTop)
yr.interp <- 15
co.i1 <- pretreatment_data(series = co, out = "accI", series.name = "co",
first = -51, last = 7500, yrInterp = yr.interp)
plot(co.i1$raw$series$age, co.i1$raw$series$char, type = "l")
lines(co.i1$int$series.int$age, co.i1$int$series.int$char, col = "red")
## Detrending
co.detr1 <- SeriesDetrend(series = co.i1, smoothing.yr = 500,
detr.type = "rob.loess", out.dir = "Figures")
co.detr1 <- SeriesDetrend(series = co.i1, smoothing.yr = 500,
detr.type = "mov.mode", out.dir = "Figures")
rm(char.thresh.gl1, co, co.i1)
series = co.detr1
proxy = "charAR"
t.lim = NULL
thresh.yr = 500
thresh.value = 0.99
noise.gmm = 1
smoothing.yr = 500
span.sm = NULL
#span.sm = 0.2
gm.local = T
keep_consecutive = F
out.dir = "Figures"
require(mclust)
# Determine path to output folder for Figures
out.path <- paste0("./", out.dir, "/")
if (dir.exists(out.path) == F) {
dir.create(out.path)
}
# Determines if analysis of all proxies or of one single proxy
if (is.null(proxy) == T) { # if proxy = NULL, use the data in series$detr$detr
if (dim(series$detr$detr)[2] > 2) {
print('Fatal error: please specify which proxy you want to use')
return()
} else {
a <- series$detr$detr
}
if (is.null(proxy) == F) { # if we want to select a specific variable
a <- data.frame(series$detr$detr$age)
colnames(a) <- "age"
a <- cbind(a, series$detr$detr[[proxy]])
colnames(a)[2] <- proxy
}
# Further extract parameters from input dataset
a.names <- colnames(a)
s.name <- series$detr$series.name
yr.interp <- series$int$yr.interp
# Determine whether to limit the analysis to a portion of the record
if (is.null(t.lim) == T) {
ageI <- a$age
}
if (is.null(t.lim) == F) {
a <- a[which(a$age <= max(t.lim) & a$age >= min(t.lim)), ]
ageI <- a$age[which(a$age <= max(t.lim) & a$age >= min(t.lim))]
}
x.lim <- c(max(ageI), min(ageI))
if (noise.gmm == 1) {
signal.gmm <- 2
}
if (noise.gmm == 2) {
signal.gmm <- 1
}
# Determine the proportion of datapoints used to smooth local thresholds with loess()
if (gm.local == T) {
n.smooth <- round(smoothing.yr/yr.interp)
if (is.null(span.sm)) {
span.sm <- n.smooth/dim(a)[1]
}
# Create empty list where output data will be stored
a.out <- list(span.sm = span.sm, thresh.value = thresh.value, yr.interp = yr.interp)
# Create space for local variables
v <- a[ ,2] # variable
v.name <- colnames(a)[2]
v.gmm <- v[which(complete.cases(v))]
y.lim <- c(min(v.gmm), max(v.gmm))
thresh.pos <- matrix(data = NA, nrow = length(v)) # threshold values
thresh.neg <- matrix(data = NA, nrow = length(v)) # threshold values
muHat <- data.frame(matrix(data = NA, nrow = length(v), ncol = 2)) # mean of noise distribution
sigmaHat <- data.frame(matrix(data = NA, nrow = length(v), ncol = 2)) # standard deviation of noise distribution
propN <- data.frame(matrix(data = NA, nrow = length(v), ncol = 2)) # proportion of each Cluster-identified distribution
#Thresh.SNI.pos <- matrix(data = NA, nrow = length(v), ncol = 1) # SNI of positive threshold
#Thresh.SNI.neg <- matrix(data = NA, nrow = length(v), ncol = 1) # SNI of negative threshold
SNIsm.pos <- matrix(data = NA, nrow = length(v), ncol = 1) # smoothed SNI of positive threshold
SNIsm.neg <- matrix(data = NA, nrow = length(v), ncol = 1) # smoothed SNI of negative threshold
Peaks.pos <- matrix(data = 0, nrow = length(v), ncol = 1) # positive peaks
Peaks.neg <- matrix(data = 0, nrow = length(v), ncol = 1) # negative peaks
# Define number of plots to print for evaluation of local threshold
j <- 1
num.plots <- seq(from = round(n.smooth), to = length(v), by = round(n.smooth/2))
my.plots <- vector(length(num.plots), mode = 'list')
# SELECT peak VALUES TO EVALUATE, BASED ON Smoothing.yr
for (i in 1:length(v)) {  #For each value in the detrended dataseries, find the threshold.
#i=3
age.i <- a[i, 1]
#cat(paste0("Calculating ", i, "th local threshold of ", length(v)))
#i=28
if (i < round(0.5*(thresh.yr/yr.interp)) + 1) { # First 'thresh.yr' samples.
#         X = v(1:round(0.5*(thresh.yr/r))); % Pre June 2009.
#         X = v(1:round(thresh.yr/r)); % Modified, June 2009, PEH.
X <- v[1:round(0.5*(thresh.yr/yr.interp)) + i] # Modified, % June 2009, PEH.
}
if (i > (length(v) - round(0.5*(thresh.yr/yr.interp)))) {  # Last 'thresh.yr' samples.
#             X = v(length(v)-...
#                 round((thresh.yr/r)):end);   % Pre June 2009.
X <- v[(i - round(0.5*(thresh.yr/yr.interp))):length(v)]   # Modified, June 2009, PEH.
# As recommended by RK, this uses samples from
# a half-window before i, all the way to end of record.
}
if (i >= round(0.5*(thresh.yr/yr.interp)) + 1 && i <= (length(v) - round(0.5*(thresh.yr/yr.interp)))) {
# All samples between first and last 'thrshYr' samples.
X <- v[(i - round(0.5*(thresh.yr/yr.interp))):(i + round(0.5*(thresh.yr/yr.interp)))]
}
## ESTIMATE LOCAL NOISE DISTRIBUTION
# Estimate noise distribution with Guassian mixture model
X.gmm <- X[which(complete.cases(X))]
if (length(X) < 3) {
cat("NOTE: Less than 3 peak values in moving window; cannot fit noise distribution.")
cat("\n      Mean and standard deviation forced to equal 0.")
cat("\n      Consider longer smoothing window (thresh.yr).")
muHat[i, ] <- 0
sigmaHat[i, ] <- 10^-100
propN[i, ] <- 0
thresh[i] <- 0
Thresh.SNI[i] <- 0
} else {
m <- mclust::densityMclust(data = X.gmm, G = 2, verbose = F)
# plot(x=m, what="density", data=X)
# summary(m, parameters=T, classification=T)
# plot.Mclust(m, what="classification")
# Get parameters from Gaussian mixture models
muHat[i, ] <- m$parameters$mean
sigmaHat[i, noise.gmm] <- sqrt(m$parameters$variance$sigmasq[noise.gmm])
sigmaHat[i, signal.gmm] <- sqrt(m$parameters$variance$sigmasq[signal.gmm])
propN[i, ] <- m$parameters$pro
# Check
if (muHat[i, noise.gmm] == muHat[i, signal.gmm]) {
warning('Poor fit of Gaussian mixture model')
}
## Define local threshold
if (!is.na(m$parameters$variance$sigmasq[noise.gmm]) == T) {
thresh.pos[i] <- m$parameters$mean[noise.gmm] + qnorm(p = thresh.value) *
sqrt(m$parameters$variance$sigmasq)[noise.gmm]
thresh.neg[i] <- m$parameters$mean[noise.gmm] - qnorm(p = thresh.value) *
sqrt(m$parameters$variance$sigmasq)[noise.gmm]
if (m$parameters$mean[noise.gmm] < 0) {
thresh.pos[i] <- 0 + qnorm(p = thresh.value) *
sqrt(m$parameters$variance$sigmasq)[noise.gmm]
}
#sig_i.pos <- X[which(X > thresh.pos[i])]
noise_i <- X[which(X <= thresh.pos[i] & X >= thresh.neg[i])]
#sig_i.neg <- X[which(X < thresh.neg[i])]
}
if (is.na(m$parameters$variance$sigmasq[noise.gmm]) == T) {
thresh.pos[i] <- 0
thresh.neg[i] <- 0
}
# Plot some of the noise and signal distributions
if (any(num.plots == i)) {
# Print plots for positive peaks
par(mfrow = c(2,1), mar = c(5,4,1,1))
plot.Mclust(m, what = "classification")
h <- hist(x = X, breaks = 50, plot = F)
dens <- hist(X, breaks = 50, plot = F)$density
plot(h, freq = F, col = "grey", border = "grey",
xlim = c(min(X, na.rm = T), max(X, na.rm = T)),
ylab = "Density", xlab = '', main = "Local threshold")
# plot(h, freq = F, col = "grey", border = "grey", xlim = c(min(h$breaks), max(h$breaks)),
#      ylab = "Density", xlab = '', main = "Local threshold")
par(new = T)
pdf2 <- curve(dnorm(x = x, mean = muHat[i, signal.gmm], sd = sigmaHat[i, signal.gmm]),
from = min(h$breaks), to = max(h$breaks),
ylim = c(0, max(dens)), type = "l", col = "blue", lwd = 1.5,
axes = F, ylab = '', xlab = '')
par(new = T)
pdf1 <- curve(dnorm(x = x, mean = muHat[i, noise.gmm], sd = sigmaHat[i, noise.gmm]),
from = min(h$breaks), to = max(h$breaks),
ylim = c(0, max(dens)), type = "l", col = "orange", lwd = 1.5,
axes = F, ylab = '', xlab = '')
par(new = T)
lines(x = c(thresh.pos[i], thresh.pos[i]), y = c(0, max(dens)),
type = "l", col = "red", lwd = 1.5)
lines(x = c(thresh.neg[i], thresh.neg[i]), y = c(0, max(dens)),
type = "l", col = "red", lwd = 1.5)
mtext(paste0(age.i, " years", "; thresh.value = ", thresh.value),
side = 3, las = 0, line = -1)
# mtext(text=paste0("SNIi pos.= ", round(Thresh.SNI.pos[i], digits=2),
#                   "SNIi neg.= ", round(Thresh.SNI.neg[i], digits=2)),
#       side=3, las=0, line=-2)
my.plots[[j]] <- recordPlot()
j <- j + 1
}
# Print pdf with selected plots that were saved at the end of the loop above
pdf(paste0(out.path, s.name, '_', v.name, '_Local_GMM_Evaluation.pdf'),
onefile = TRUE, paper = "a4")
par(mfrow = (c(5,5)), mar = c(0.5,1,0.5,1), oma = c(1,1,0.5,1), cex = 0.7)
for (k in 1:length(num.plots)) {
replayPlot(my.plots[[k]])
}
dev.off()
## Calculate SNI:
if (is.null(proxy)) {
SNIsm.pos <- SNI(ProxyData = cbind(series$int$series.int$age,
series$int$series.int[ ,2],
thresh.pos),
BandWidth = smoothing.yr)$SNI_sm
SNIsm.neg <- SNI(ProxyData = cbind(series$int$series.int$age,
-1 * series$int$series.int[ ,2],
-1 * thresh.neg),
BandWidth = smoothing.yr)$SNI_sm
} else {
SNIsm.pos <- SNI(ProxyData = cbind(series$int$series.int$age,
series$int$series.int[[proxy]],
thresh.pos),
BandWidth = smoothing.yr)$SNI_sm
SNIsm.neg <- SNI(ProxyData = cbind(series$int$series.int$age,
-1 * series$int$series.int[[proxy]],
-1 * thresh.neg),
BandWidth = smoothing.yr)$SNI_sm
}
thresh.pos.sm <- stats::lowess(ageI, thresh.pos, f = span.sm, iter = 0)$y
thresh.neg.sm <- stats::lowess(ageI, thresh.neg, f = span.sm, iter = 0)$y
## Get peaks
if (keep_consecutive == F) { # if consecutive peaks should be removed
# Flag values exceeding thresholds
Peaks.pos[which(v > thresh.pos.sm)] <- 2
Peaks.neg[which(v < thresh.neg.sm)] <- 2
# Then remove consecutive peaks
# For positive peaks
for (i in 1:(length(Peaks.pos) - 1)) { # For each value in Charcoal.peak
if (Peaks.pos[i] > 0
&& Peaks.pos[i + 1] > 0) {  # if two consecutive values > 0
Peaks.pos[i] <- 1           # keep first as 2, mark subsequent (earlier) as 1
}
for (i in 1:length(Peaks.pos)) {
if (Peaks.pos[i] < 2) {    # if value < 2
Peaks.pos[i] <- 0        # mark sample as 0 (unflag Peak)
} else {
Peaks.pos[i] <- 1        # else (if value=2) mark sample as 1 (flag as Peak)
}
# For negative peaks
for (i in 1:(length(Peaks.neg) - 1)) { # For each value in Charcoal.peak
if (Peaks.neg[i] > 0
&& Peaks.neg[i + 1] > 0) {  # if two consecutive values > 0
Peaks.neg[i] <- 1           # keep first as 2, mark subsequent (earlier) as 1
}
for (i in 1:length(Peaks.neg)) {
if (Peaks.neg[i] < 2) {    # if value < 2
Peaks.neg[i] <- 0        # mark sample as 0 (unflag Peak)
} else {
Peaks.neg[i] <- 1        # else (if value=2) mark sample as 1 (flag as Peak)
}
} else {
Peaks.pos[which(v > thresh.pos.sm)] <- 1
Peaks.neg[which(v < thresh.neg.sm)] <- 1
}
## Plot series with trend + threshold + peaks
Peaks.pos.plot <- which(Peaks.pos > 0)
Peaks.neg.plot <- which(Peaks.neg > 0)
peaks.pos.ages <- ageI[which(Peaks.pos == 1)]
peaks.neg.ages <- ageI[which(Peaks.neg == 1)]
## Calculate Event Return Intervals
RI_neg <- c(diff(peaks.neg.ages), NA)
RI_pos <- c(diff(peaks.pos.ages), NA)
peaks.pos.ages
View(Plot_ReturnIntervals)
source('~/Documents/GitHub/R-PaleoAnomalies_notGit_v2/test_with_CO_Char.R')
View(Plot_ReturnIntervals)
source("./R/Plot_ReturnIntervals.r")
View(Plot_ReturnIntervals)
source('~/Documents/GitHub/R-PaleoAnomalies_notGit_v2/test_with_CO_Char.R')
