#' Import a trend determined by GAM into tapas
#'
#' @description
#' mgcv2tapas() makes it easy to import a trend that was generated with the
#' \code{mgcv::gam()} function into the tapas environment, such that the
#' data can be further analysed for peaks with the \code{tapas::global_thresh()}
#'  or the \code{tapas::local_thresh()} functions.
#'
#' @param series A list generated with the \code{mgcv::gam()} function
#'
#' @param data_type The dimension of the input variable. By default,
#'                  \code{data_type} = "accI", i.e. binned accumulation rates.
#'                  Other options include: "acc", "con", or "count" for
#'                  non-binned accumulation rates, concentrations, or counts,
#'                  respectively. Or "conI" and "countI" for binned
#'                  concentrations and counts, respectively.
#'
#' @param series.name A string defining the name of the input matrix, typically
#'                    the site name. Defaults to NA.
#'
#' @param plotit Logical. If \code{plotit} == TRUE, figures are plotted to the
#'               current device.
#'
#' @details
#' mgcv2tapas() extracts data from the list that was generated with the
#'  \code{mgcv::gam()} function. In addition, it fetches data from the
#'  data frame that was called by the \code{mgcv::gam()} function. Thus,
#'  that data frame has to be available in the R environment.
#'
#'  The function additionally plots the data along with the GAM-modeled
#'  trend (red line) and the 2 standard errors of the GAM model (blue lines),
#'  and plots the detrended data with the GAM-modeled trend.
#'
#'
#' @returns
#' mgcv2tapas() returns a list that can be further processed to detect peaks
#' with the \code{tapas::global_thresh()} or the \code{tapas::local_thresh()}
#' functions.
#'
#' mgcv2tapas() returns a \code{tapas::SeriesDetrend()}-styled list.
#'  The GAM-modeled trend is stored in the $detr sublist.
#'  To populate the $int sublist, which is typically generated by the
#'  \code{tapas::pretreatment_data()} function, mgcv2tapas() pulls the
#'  necessary data from the data frame that was called by the
#'  \code{mgcv::gam()} function. Thus, either from a data frame that was
#'  generated with the \code{tapas::tapas2mgcv()} function (if the data was
#'  binned), or from a non-binned data frame (that has the same format as the
#'  input data frame for the \code{tapas::pretreatment_data()} function).
#'
#'  The $int sublist includes three sublists:
#'  - the $series.int sublist contains the data that was used by the
#'  \code{mgcv::gam()} function and that can be further processed with the
#'  \code{tapas::global_thresh()} or the \code{tapas::local_thresh()} functions.
#'  In the case of sedimentary charcoal records, this data has typically the
#'  dimension of charcoal-accumulation rates.
#'  - the $series.conI and the $series.countI sublists should contain the
#'  concentration and count values, respectively. To generate these data sets,
#'  mgcv2tapas() requires a user-determined parameter (\code{data_type}) that
#'  declares the dimension of the input data. If \code{data_type} == "accI" or
#'  "acc", the data for the $series.conI and the $series.countI sublists
#'  is calculated by mgcv2tapas(). If \code{data_type} == "conI", or
#'  "con", the $series.int and the $series.conI will contain the same data.
#'  If \code{data_type} == "countI" or "count", the $series.int and the
#'  $series.countI will contain the same data.
#'
#' @seealso [tapas2mgcv()]
#'
#' @importFrom dplyr all_of
#' @importFrom dplyr pull
#' @importFrom mgcv predict.gam
#' @importFrom stringr str_replace
#'
#' @author Walter Finsinger
#'
#' @export


mgcv2tapas <- function(series = NULL,
                       data_type = "accI",
                       series.name = NA,
                       plotit = TRUE) {

  ## Put the userâ€™s layout settings back in place when the function is done
  opar <- par("mfrow", "mar", "oma", "cex")
  on.exit(par(opar))

  ## Extract data ####

  ## Extract data from the list that was generated by the mgcv::gam() function
  x_var_name <- series[["pred.formula"]][[2]]
  y_var_name <- series[["pterms"]][[2]]
  age_top <- series[["model"]] %>%
    dplyr::pull(dplyr::all_of(x_var_name))
  y_raw <- series[["model"]] %>%
    dplyr::pull(dplyr::all_of(y_var_name))

  ## Extract data from the data frame used to run the mgcv::gam() function
  d_raw_name <- as.character(series[["call"]][["data"]])
  d_raw <- get(d_raw_name)
  age_bot <- d_raw %>%
    dplyr::pull(var = 4)
  volI <- d_raw %>%
    dplyr::pull(var = 5)


  ## Check if the data was binned with tapas::pretreatment_data() ####
  if (sd(diff(age_top)) == 0) { # if yes:
    yr.interp <- mean(diff(age_top))
    series_type <- "binned"
  } else { # if not:
    yr.interp <- NULL
    series_type <- "not-binned"
  }

  ## Get the GAM values for the data points ####
  y_trend <- mgcv::predict.gam(object = series, se.fit = T,
                               type = "response")$fit
  y_se <- mgcv::predict.gam(object = series, se.fit = T,
                            type = "response")$se.fit


  ## Detrend the data ####
  y_detr <- y_raw - y_trend


  ## Get concentrations and counts ####

  ## If data_type is Accumulation rates:
  if (data_type == "accI" | data_type == "acc") {
    y_conc <- y_raw * abs(age_top - age_bot)
    y_counts <- y_conc * volI
    y_name <- stringr::str_replace(as.character(y_var_name), "AR", "")
  }

  ## If data_type is Concentrations:
  if (data_type == "conI" | data_type == "con") {
    y_conc <- y_raw
    y_counts <- y_raw * volI
    y_name <- y_var_name
  }

  ## If data_type is Counts:
  if (data_type == "countI" | data_type == "count") {
    y_conc <- y_raw / volI
    y_counts <- y_raw
    y_name <- y_var_name
  }


  ## Insert extracted data into a tapas::SeriesDetrend()-styled list ####
  series <- as.data.frame(cbind(age_top, y_raw))
  colnames(series) <- c("age", y_var_name)
  raw <- list(series = series, series.name = series.name)

  series.int <- series
  series.conI <- as.data.frame(cbind(age_top, y_conc))
  colnames(series.conI) <- c("age", y_name)
  series.countI <- as.data.frame(cbind(age_top, y_counts))
  colnames(series.countI) <- c("age", y_name)

  int <- list(series.int = series.int, series.conI = series.conI,
              series.countI = series.countI,
              volI = volI, yr.interp = yr.interp, type = series_type)

  detr <- as.data.frame(cbind(age_top, y_detr))
  colnames(detr) <- c("age", y_var_name)
  detr <- list(detr = detr, smoothing.yr = NULL, detr.type = "GAM",
               series.name = series.name)

  output <- list(raw = raw, int = int, out = data_type, detr = detr)


  ## Plot the extracted and detrended data ####
  if (plotit == T) {
    x_lim <- c(max(age_top), min(age_top))
    y_lim <- c(0, max(y_raw))

    ## Plot the extracted data
    par(mfrow = c(2,1), mar = c(2,5,2,2), oma = c(2,1,1,1))
    plot(age_top, y_raw, type = "s",
         xlim = x_lim, ylim = y_lim,
         xlab = x_var_name, ylab = y_var_name,
         axes = F)
    axis(1)
    axis(2)
    lines(age_top, y_trend, col = "red")
    lines(age_top, y_trend + 2*y_se, col = "blue")
    lines(age_top, y_trend - 2*y_se, col = "blue")

    ## Plot the detrended data
    x_lim <- c(max(age_top), min(age_top))
    y_lim <- c(min(y_detr), max(y_detr))

    plot(age_top, y_detr, type = "s",
         xlim = x_lim, ylim = y_lim,
         xlab = x_var_name, ylab = paste('detrended', y_var_name),
         axes = F)
    axis(1)
    axis(2)
    abline(h = 0)
    lines(age_top, 2*y_se, col = "red", lwd = 1)
    lines(age_top, -2*y_se, col = "red", lwd = 1)
  }

  return(output)
}
